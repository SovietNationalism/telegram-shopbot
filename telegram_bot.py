import os, sys, logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler,
    MessageHandler, filters, ContextTypes
)
from telegram.error import BadRequest

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  CONFIG  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #

BOT_TOKEN         = os.getenv("BOT_TOKEN")
ADMIN_USER_ID     = 6840588025
WELCOME_IMAGE_URL = "https://i.postimg.cc/pr65RVVm/D6F1EDE3-E7E8-4ADC-AAFC-5FB67F86BDE3.png"

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)
if not BOT_TOKEN:
    logger.critical("‚ùå BOT_TOKEN missing."); sys.exit(1)

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  BOT CLASS  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #

class ShopBot:
    def __init__(self):
        # --------------------  PRODUCTS -------------------- #
        self.products = {
            "2": {
                "name": "Sciroppo al THC",
                "price": (
                    "x 1 150 ml 30‚Ç¨\n"
                    "x 2 300 ml 40‚Ç¨\n"
                    "x 5 750 ml 100‚Ç¨\n"
                    "x 10 1,5 l 190‚Ç¨\n"
                    "x 20 3 l 335‚Ç¨"
                ),
                "caption": (
                    "üì¶ Sciroppo al THC, formato 100 ml 200 mg\n"
                    "üíµ Prezzo:\n"
                    "x 1 30‚Ç¨ (non ordinabile singolarmente)\n"
                    "x 2 45‚Ç¨\n"
                    "x 4 60‚Ç¨\n"
                    "x 5 75‚Ç¨\n"
                    "x 10 140‚Ç¨\n"
                    "x 20 265‚Ç¨\n"
                    "üìù Descrizione: \n"
                    "Composta da estratto di hashish a base di etanolo, emulsionato in uno sciroppo dolce per una stabilit√† e biodisponibilit√† superiore.\n"
                    "Da mescolare con qualsiasi tipo di bevanda! Consigliamo liquidi freddi e dolci per coprire il sapore.\n"
                    "Scuotere la boccetta prima di ogni uso per distribuirlo bene.\n"
                    "Gusti: Lampone, Limone\n"
                    "Per un aggiunta di 5‚Ç¨, un sapore a richiesta (es. cola, passion fruit, mela, etc) pu√≤ essere preparato.\n"
                    "Dosaggio consigliato (2 mg/ml):\n"
                    "üü¢ Principianti: 10‚Äì15 mg (5‚Äì7.5 ml circa)\n"
                    "üü° Regolari: 25‚Äì35 mg (12.5‚Äì17.5 ml)\n"
                    "üî¥ Esperti: 50 + mg (25 ml e oltre)\n"
                    "Ricordarsi che gli ml non equivalgono ai grammi."
                ),
                "video_file_id": "BAACAgQAAxkBAAKFGWkBIwRzsDfApvLm5zxk_WBRChDAAAIvKwAC5UMJUK8HDZt1QSigNgQ",
            },
            "3": {
                "name": "Promo sconto",
                "caption": (
                    "PROMO CLIENTI\n"
                    "I pacchetti di Ottobre sono:\n"
                    "5g frozen 5g weed 105‚Ç¨\n"
                    "10g frozen + 1 sciroppo 135‚Ç¨\n"
                    "+ Se aggiungi un brownie ai seguenti ordini costa solo 5‚Ç¨!\n"
                    "\n"
                    "PROGRAMMA REFERRAL\n"
                    "Vuoi fumare GRATIS? Ti basta portare clienti!\n"
                    "Ogni volta che un tuo amico compra da noi, tu guadagni!\n"
                    "\n"
                    "Come funziona:\n"
                    "1Ô∏è‚É£ Invita un amico a ordinare da noi.\n"
                    "2Ô∏è‚É£ Quando compra, ci dice che lo hai inviato TU.\n"
                    "3Ô∏è‚É£ Tu guadagni subito 1g gratis di erba o dry (o 5‚Ç¨ di credito verso gli altri prodotti) ogni volta che spende 40‚Ç¨.\n"
                    "\n"
                    "Regole:\n"
                    "Il cliente deve comunicare il tuo @username al momento dell‚Äôordine.\n"
                    "Se preferisci, puoi accumulare i crediti e spenderli quando vuoi.\n"
                    "I crediti valgono per qualsiasi prodotto (vape, edibili, sciroppi, ecc.).\n"
                ),
                "video_file_id": None,
            },
            "4": {
                "name": "THC Vapes Packwoods‚Ñ¢ x Runtz",
                "price": "1 - 45\n2 - 80\n3 - 110\n4 - 135\n5 - 160\n10 - 300",
                "description": "Con 1000 mg di distillato Delta-9 THC, basta una decina di tiri per sentire una fattanza potente.",
                "special_note": "DISPONIBILI!!.",
                "video_file_id": "BAACAgQAAxkBAAIFf2jLLB8yvdGJo8oIv_8LTJ8HBethAAJ3HAACQu5gUmZ8c0unLksLNgQ",
            },
            "5": {
                "name": "Brownies al THC",
                "caption": (
                    "DISPONIBILE\n\n"
                    "üì¶ *THC Brownies*\n"
                    "üíµ Prezzo:\n1pz 10‚Ç¨ (non ordinabile singolarmente)\n2pz 20‚Ç¨\n5pz 40‚Ç¨\n10pz 70‚Ç¨\n20pz 130‚Ç¨\n50pz 280‚Ç¨\n\n"
                    "üìù Descrizione: Prodotti fornari con ora 70 mg di THC per pezzo, preparato "
                    "con burro infuso e lecitina per un effetto potente e ben distribuito.\n"
                    "‚ö†Ô∏è Non consumate l‚Äôintero brownie (a meno che non abbiate una tolleranza alta).\n"
                    "Ogni brownie contiene almeno 70 mg di THC; consigliamo di dividerlo con un amico o "
                    "conservarne met√† per dopo.\n"
                    "üí° Pro tip: Scaldatelo nel microonde per 10‚Äì20 s e impiattatelo prima di mangiarlo: sar√† caldo "
                    "e ancora pi√π buono!"
                ),
                "video_file_id": "BAACAgQAAxkBAAKFQWkBJWdYQlJV45y5vgY_vGhS-aQnAAIyKwAC5UMJUAUSNKi6rfVtNgQ",
            },
            "9": {
                "name": "Dry Filtre 73/90u",
                "caption": (
                    "üì¶ *Filtrato*\n"
                    "üíµ Prezzo:\n"
                    "3g 30‚Ç¨\n5g 45‚Ç¨\n10g 70‚Ç¨\n15g 110‚Ç¨\n20g 125‚Ç¨\n25g 150‚Ç¨\n30g 175‚Ç¨\n50g 250‚Ç¨\n70g 335‚Ç¨\n100g 450‚Ç¨\n"
                    "üìù Descrizione: Un drysift filtrato a 90/73u.\nFumata piacevole e corposa, sapore pieno e naturale, con una botta lunga e pulita.\nUn hash lavorato bene, di alta qualit√†."
                ),
                "video_file_id": "BAACAgQAAxkBAAKBFGj_z4A3oJEDk4Yj7NpUv8EawKKAAAJJHAAC6zEBUClCz0loabJtNgQ",
            },
            "10": {
                "name": "NUOVA ERBA COMING SOON",
                "caption": (
                    "üì¶ *Citronella Kush üçã*\n"
                    "üíµ Prezzo:\n"
                    "3.5 35‚Ç¨\n"
                    "5g 45‚Ç¨\n"
                    "8g 70‚Ç¨\n"
                    "10g 80‚Ç¨\n"
                    "15g 115‚Ç¨\n"
                    "28g 185‚Ç¨\n"
                    "40g 265‚Ç¨\n"
                    "50g 300‚Ç¨\n"
                    "70g 390‚Ç¨\n"
                    "100g 500‚Ç¨\n\n"
                    "üìù Descrizione: Sold out nuova weed restock ritardato leggermente.."
                ),
                "video_file_id": "BAACAgQAAxkBAAP-aMm2JcuYvMEc2e-Xlzg8rE7ytTwAApAaAAICDkhS2xCWqGMGGS42BA",
            },
            "11": {
                "name": "Caramelle 500mg THC",
                "caption": (
                    "üì¶ *500mg THC gummies üç¨*\n"
                    "üíµ Prezzo:\n"
                    "1 - 30\n"
                    "2 - 45\n"
                    "3 - 65\n"
                    "5 - 100\n"
                    "10 - 180\n\n"
                    "üìù Descrizione: Caramelle gommose in formato da 20 caramelle da 25 mg l‚Äôuna. Effetto piacevole, rilassante e duraturo, molto divertenti e comode da consumare."
                ),
                "video_file_id": "BAACAgQAAxkBAAIFfWjLK8Fs4ZE3FisMbr8bMsAhmIyEAAJ2HAACQu5gUt0aqGYUVbjHNgQ",
            },
        }

        # --------------------  ALTRO -------------------- #
        self.tabaccheria_items = {
            "svc2_blunts": {
                "title": "Juicy Jay‚Äôs Hemp Wraps ‚Äì Red Alert",
                "caption": "Juicy Jay‚Äôs Hemp Wraps ‚Äì Red Alert\n1 pacchetto 2‚Ç¨\n5 pacchetti 8.50‚Ç¨\n10 pacchetti 14.50‚Ç¨\n20 pacchetti 22‚Ç¨",
                "video_file_id": "BAACAgQAAxkBAAI1KGjncIEkzh98_mRRwgoY5OEBzFgoAAJJGgACT6c5UwmW8tpHW1IqNgQ"
            },
            "svc2_papers": {
                "title": "RAW Cartine King Size Slim",
                "caption": "RAW Cartine King Size Slim\n1 cartina 1.20‚Ç¨\n5 cartine 5‚Ç¨\n10 cartine 8.50‚Ç¨\n25 cartine 20‚Ç¨",
                "video_file_id": "BAACAgQAAxkBAAI1JGjncFNO1ELRJ6fuaye9nvEjHmYZAAJHGgACT6c5U5SFr4CjhHPbNgQ"
            },
            "svc2_filters": {
                "title": "RAW Filtri Perforated Wide",
                "caption": "RAW Filtri Perforated Wide\n1 pacchetto 1‚Ç¨\n5 pacchetti 4‚Ç¨\n10 pacchetti 7‚Ç¨\n25 pacchetti 15‚Ç¨",
                "video_file_id": "BAACAgQAAxkBAAI1Imjnb_Caqs6QPfzRxWx-cuEcD0rsAAJFGgACT6c5U7iZs8oUq-jANgQ"
            },
            "svc2_kits": {
                "title": "Kit RAW (cartine + filtri)",
                "caption": "Kit RAW (cartine + filtri)\n1 kit 1.80‚Ç¨\n5 kit 8‚Ç¨\n10 kit 15‚Ç¨\n25 kit 33.50‚Ç¨",
                "video_file_id": "BAACAgQAAxkBAAI1JmjncHc0x5rbWK1Pu44-XkrMyuxgAAJIGgACT6c5U0QzjXcQJZWfNgQ"
            },
        }

        self.services = {
            "1": {
                "name": "Creazione Bot Telegram",
                "price": "‚Ç¨35/m",
                "description": "Sei un venditore o comunque sei interessato alla creazione di un bot simile? Posso aiutarti.",
                "photo_file_id": "AgACAgQAAxkBAAIBVmY0n9f5v1cAAQ1nUuH4QnX8h3QjAAJ8tzEbJ2FTkJ7yK5y1vN2BAAMCAANzAAMvBA",
                "video_file_id": None,
            },
            "4": {
                "name": "Creazione etichette spedizione",
                "price": "",
                "description": (
                    "Ti creer√≤ una etichetta da spedizione personalizzata per i seguenti corrieri e costi:\n\n"
                    "INPOST - 10‚Ç¨\n"
                    "POSTE STANDARD - 10‚Ç¨\n"
                    "POSTE EXPRESS - 15‚Ç¨\n"
                    "BRT - 20‚Ç¨\n"
                    "GLS/UPS - 20‚Ç¨\n\n"
                    "Per quantit√† si possono organizzare prezzi ridotti."
                ),
                "photo_file_id": None,
                "video_file_id": None,
            },
        }

        # Track users for broadcast (kept as in prior code)
        self.user_ids = set()

        # ------------------  REGOLAMENTO  ------------------ #
        self.rules_text = (
            "üì¶ Spedizioni in tutta Italia\n"
            "1. Scrivici in privato indicando prodotto, quantit√† e modalit√† di pagamento.\n"
            "2. Riceverai conferma con prezzo.\n"
            "3. Consegna rapida e gratuita (salvo eccezioni) tramite InPost o corriere a scelta.\n\n"
            "‚∏ª\n\n"
            "ü§ù Meet-up a Mantova / Consegna a mano\n"
            "Per sicurezza reciproca, i meet-up seguono regole precise. Se non le accetti, non si procede.\n\n"
            "üîç Verifica obbligatoria (solo per meet-up)\n"
            "Per essere verificato invia:\n"
            "‚Ä¢ Foto della tua carta d‚Äôidentit√† (anche retro)\n"
            "‚Ä¢ Foto di te con la somma in mano\n"
            "‚Ä¢ Screenshot del tuo profilo Instagram attivo\n\n"
            "‚ö†Ô∏è Nessun meet-up sar√† confermato senza verifica. La ragione di queste verifiche √® prevenire rapine, "
            "perdite di tempo, ecc. A fine transazione tutto verr√† eliminato per la vostra sicurezza.\n\n"
            "üìã Regole meet-up / delivery\n"
            "‚Ä¢ Presentati da solo. Se porti qualcuno, deve essere verificato anche lui.\n"
            "‚Ä¢ Contanti gi√† contati e giusti, non garantiamo resto.\n"
            "‚Ä¢ Si mostra e conta la somma prima del prodotto.\n"
            "‚Ä¢ Il luogo lo scelgo io. Orario concordato in anticipo.\n"
            "‚Ä¢ Nessuna tolleranza per perditempo o comportamenti sospetti.\n"
            "‚Ä¢ Il rider √® sempre armato. Non ci pensate nemmeno.\n\n"
            "‚∏ª\n\n"
            "üöó Delivery su Citt√† Limitrofe\n\n"
            "Ordine minimo 50‚Ç¨\n"
            "Zone vicine a Mantova (entro 15 km) ‚Äì 15/20‚Ç¨.\n"
            "Verona ‚Äì 25‚Ç¨\n"
            "Brescia ‚Äì 30‚Ç¨\n"
            "Modena ‚Äì 25‚Ç¨\n"
            "Cremona ‚Äì 35‚Ç¨\n"
            "Reggio Emilia ‚Äì 35‚Ç¨\n"
            "Carpi ‚Äì 30‚Ç¨\n"
            "Parma ‚Äì 35‚Ç¨"
        )

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  HELPER: relay  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #
    async def _relay_to_admin(self, context: ContextTypes.DEFAULT_TYPE, who, what: str) -> None:
        message = f"üë§ {who.full_name} ({who.id})\nüí¨ {what}"
        logger.info(message)
        try:
            await context.bot.send_message(ADMIN_USER_ID, message)
        except Exception as e:
            logger.warning(f"Failed to relay to admin: {e}")

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  COMMANDS  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #
    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        self.user_ids.add(update.effective_user.id)
        await self.delete_last_menu(context, update.effective_chat.id)

        kb = [
            [InlineKeyboardButton("üõçÔ∏è Shop üõçÔ∏è", callback_data="shop")],
            [InlineKeyboardButton("üí¨ Chat Clienti üí¨", url="https://t.me/+a3rvmx13cjo5MjE0")],
            [InlineKeyboardButton("üí∞ Pagamenti üí∞", callback_data="payments")],
            [InlineKeyboardButton("üìã Regolamento üìã", callback_data="rules")],
            [InlineKeyboardButton("üì¢ Canale Telegram üì¢", url="https://t.me/+A3JnK9ALAmtiMjBk")],
            [InlineKeyboardButton("üë• Ordina Scrivendomi Qui üë•", callback_data="contact")],
        ]
        msg = (
            "üéâ Benvenuto sul bot Vetrina ItalianEdibles! üáÆüáπ\n\n"
            "Scopri un mondo di prodotti selezionati, pensati per un'esperienza unica e "
            "indimenticabile. Puoi esplorare e contattarci in pochi semplici clic!"
        )
        m = update.effective_message
        try:
            sent = await m.reply_photo(photo=WELCOME_IMAGE_URL, caption=msg, reply_markup=InlineKeyboardMarkup(kb))
            context.user_data["last_menu_msg_id"] = sent.message_id
        except BadRequest:
            sent = await m.reply_text(text=msg, reply_markup=InlineKeyboardMarkup(kb))
            context.user_data["last_menu_msg_id"] = sent.message_id

    async def broadcast(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        if update.effective_user.id != ADMIN_USER_ID:
            await update.message.reply_text("‚ùå Non sei autorizzato a usare questo comando.")
            return

        if not context.args:
            await update.message.reply_text("‚ùó Usa correttamente: /broadcast <messaggio>")
            return

        message = " ".join(context.args)
        count = 0
        for uid in list(self.user_ids):
            try:
                await context.bot.send_message(uid, f"üì¢ {message}")
                count += 1
            except Exception as e:
                logger.warning(f"Impossibile inviare a {uid}: {e}")

        await update.message.reply_text(f"‚úÖ Messaggio inviato a {count} utenti.")

    async def delete_last_menu(self, context, chat_id):
        msg_id = context.user_data.get("last_menu_msg_id")
        if msg_id:
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
            except:
                pass
            context.user_data["last_menu_msg_id"] = None

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  CALLBACKS  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #
    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        q   = update.callback_query
        d   = q.data
        cid = q.message.chat.id
        self.user_ids.add(update.effective_user.id)

        await q.answer()

        if update.effective_user.id != ADMIN_USER_ID:
            await self._relay_to_admin(context, update.effective_user, f"Pressed button: {d}")

        await self.delete_last_menu(context, cid)

        # ---------- REGOLAMENTO ---------- #
        if d == "rules":
            kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="back_to_main")]]
            sent = await context.bot.send_message(chat_id=cid, text=self.rules_text, reply_markup=InlineKeyboardMarkup(kb))
            context.user_data["last_menu_msg_id"] = sent.message_id
            return

        # ---------- TORNA AL MAIN ---------- #
        if d == "back_to_main":
            await self.start(update, context)
            return
            
        # ---------- SHOP ---------- #
        if d == "shop":
            kb = [
                [
                    InlineKeyboardButton("üì± Prodotti THC", callback_data="products"),
                    InlineKeyboardButton("üö¨ Tabaccheria",   callback_data="service_2"),
                ],
                [
                    InlineKeyboardButton("üõ†Ô∏è Servizi",      callback_data="services"),
                    InlineKeyboardButton("‚ú® Offerte",       callback_data="product_3"),
                ],  
                [InlineKeyboardButton(‚Äúüí∏ Rimborsi Amazon‚Äù, callback_data=‚Äúamazon_refunds‚Äù)],
                [InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="back_to_main")],
            ]
            sent = await context.bot.send_message(
                chat_id=cid,
                text="üõçÔ∏è *SHOP*\n\nScegli una categoria:",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(kb)
            )
            context.user_data["last_menu_msg_id"] = sent.message_id
            return

        # ---------- PAGAMENTI ---------- #
        if d == "payments":
            kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="back_to_main")]]
            payments_text = (
                "üí∞ *METODI DI PAGAMENTO*\n\n"
                "‚Ä¢ üè¶ Bonifico istantaneo (0% commissione)\n"
                "‚Ä¢ üì≤ Hype / Revolut / Sumup / Tinaba (0% commissione)\n"
                "‚Ä¢ üí∏ Crypto LTC / BTC (0% commissione)\n"
                "‚Ä¢ üí∂ Contanti spediti o in meet up (0% commissione)\n"
                "‚Ä¢ üí≥ PayPal / Satispay (+10% commissione)\n"
                "‚Ä¢ üíº Bonifico dal tabacchino (+10% commissione)\n"
                "‚Ä¢ ‚úâÔ∏è Gift card prepagate/crypto (Bitnovo, Epipoli, Paysafecard, etc...) (+10% commissione)\n"
                "‚Ä¢ üè∑Ô∏è Buoni regalo (+50% commissione)\n\n"
                "üì¶ *POLITICA DI RESHIP E ASSISTENZA*\n\n"
                "In caso di pacco smarrito in transito √® previsto il rimborso o rispedizione del materiale.\n"
                "Per resi o problemi sul prodotto, √® obbligatorio fornire:\n"
                "‚Ä¢ üé• Un video senza tagli dell‚Äôapertura del locker\n"
                "‚Ä¢ üé• Un video senza tagli dell‚Äôapertura del pacco\n\n"
                "‚ö†Ô∏è In entrambi i video devono essere mostrati tutti i lati del pacco, per verificare che non sia stato manomesso.\n\n"
            )
            sent = await context.bot.send_message(
                chat_id=cid,
                text=payments_text,
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(kb)
            )
            context.user_data["last_menu_msg_id"] = sent.message_id
            return

        # ---------- CONTACT ---------- #
        if d == "contact":
            txt = "üë• *COME ORDINARE*\n\nClicca il pulsante qui sotto per contattarmi, scrivimi il tuo ordine, se √® ship/meetup/delivery, e la modalit√† di pagamento che hai scelto.\nTutte le opzioni disponibile sono visibili nel bot:"
            kb = [
                [InlineKeyboardButton("‚úâÔ∏è Scrivimi", url="https://t.me/ItalianEdibles")],
                [InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="back_to_main")]
            ]
            sent = await context.bot.send_message(
                chat_id=cid,
                text=txt,
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(kb)
            )
            context.user_data["last_menu_msg_id"] = sent.message_id
            return

        # ---------- LISTA PRODOTTI ---------- #
        if d in ("products", "back_to_products"):
            kb = [
                [InlineKeyboardButton(self.products["2"]["name"], callback_data="product_2")],
                [InlineKeyboardButton(self.products["4"]["name"], callback_data="product_4")],
                [InlineKeyboardButton(self.products["5"]["name"], callback_data="product_5")],
                [InlineKeyboardButton(self.products["9"]["name"], callback_data="product_9")],
                [InlineKeyboardButton(self.products["10"]["name"], callback_data="product_10")],
                [InlineKeyboardButton(self.products["11"]["name"], callback_data="product_11")],
                [InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="shop")]
            ]
            sent = await context.bot.send_message(
                chat_id=cid,
                text="üì± *PRODOTTI THC DISPONIBILI*\n\nScegli un prodotto:",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(kb)
            )
            context.user_data["last_menu_msg_id"] = sent.message_id
            return

        # ---------- LISTA ALTRO ---------- #
        if d in ("services", "back_to_services"):
            kb = [
                [InlineKeyboardButton(s["name"], callback_data=f"service_{sid}")]
                for sid, s in self.services.items()
            ] + [[InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="shop")]]
            sent = await context.bot.send_message(
                chat_id=cid,
                text="üîß *ALTRO*\n\nScegli un elemento:",
                parse_mode=ParseMode.MARKDOWN,
                reply_markup=InlineKeyboardMarkup(kb)
            )
            context.user_data["last_menu_msg_id"] = sent.message_id
            return
            
        if d == "amazon_refunds":
            text = (
                "Collab @ItalianEdibles x @F2rrar1 üí•\n\n"
                "VUOI RICEVERE MERCE ONLINE A PREZZI ALTAMENTE RIBASSATI? üëÄ\n\n"
                "Il mio amico @F2rrar1 √® qui per te!\n"
                "Offre un servizio esclusivo per farti ricevere ordini da Amazon, Apple e molti altri store a meno della met√† del prezzo originale.\n"
                "Decidi cosa ordinare e lui far√† in modo che tu venga rimborsato in pieno. üí∏\n\n"
                "üí∞ Bonus esclusivo per i nostri membri:\n"
                "Se compri da lui, il 10% di quello che spendi si trasforma in crediti spendibili da noi!\n"
                "Esempio: se lo paghi 200‚Ç¨ per un portatile, ricevi un buono da 20‚Ç¨ da utilizzare su qualsiasi ordine nel nostro store. üî•\n\n"
                "üìã Condizioni:\n"
                "Quando ordini da @F2rrar1, ricorda di menzionare questo annuncio per ricevere il cashback."
            )
            kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="shop")]]
            sent = await context.bot.send_message(
                chat_id=cid, text=text, reply_markup=InlineKeyboardMarkup(kb)
            )
            context.user_data["last_menu_msg_id"] = sent.message_id
            return

        if d.startswith("product_"):
            key = d.split("_", 1)[1]
            prod = self.products.get(key)
            if not prod:
                await q.answer("‚ùå Prodotto non trovato!")
                return

            if "caption" in prod and prod["caption"]:
                caption = prod["caption"]
            elif key == "4":
                caption = (
                    f"üì¶ *{prod['name']}*\n"
                    f"üíµ Prezzo:\n{prod['price']}\n"
                    f"üìù Descrizione: {prod['description']}\n\n"
                    f"*{prod['special_note']}*"
                )
            else:
                parts = [f"üì¶ *{prod['name']}*"]
                price = (prod.get('price') or '').strip()
                if price:
                    parts.append(f"üíµ Prezzo:\n{price}")
                desc = (prod.get('description') or '').strip()
                if desc:
                    parts.append(f"üìù Descrizione: {desc}")
                caption = "\n".join(parts)

            kb_back = InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Torna ai Prodotti", callback_data="back_to_products")]])

            if prod.get("video_file_id"):
                try:
                    sent = await context.bot.send_video(chat_id=cid, video=prod["video_file_id"], caption=caption,
                                                        parse_mode=ParseMode.MARKDOWN, supports_streaming=True,
                                                        reply_markup=kb_back)
                    context.user_data["last_menu_msg_id"] = sent.message_id
                except BadRequest:
                    sent = await context.bot.send_message(chat_id=cid, text=caption, parse_mode=ParseMode.MARKDOWN,
                                                          reply_markup=kb_back)
                    context.user_data["last_menu_msg_id"] = sent.message_id
            else:
                sent = await context.bot.send_message(chat_id=cid, text=caption, parse_mode=ParseMode.MARKDOWN,
                                                      reply_markup=kb_back)
                context.user_data["last_menu_msg_id"] = sent.message_id
            return
            
        # ---------- TABACCHERIA SUBMENU ---------- #
        if d == "service_2":
            kb = [
                [
                    InlineKeyboardButton("üö¨ Blunts",  callback_data="svc2_blunts"),
                    InlineKeyboardButton("üßª Papers",  callback_data="svc2_papers"),
                ],
                [
                    InlineKeyboardButton("üß∑ Filters", callback_data="svc2_filters"),
                    InlineKeyboardButton("üì¶ Kits",    callback_data="svc2_kits"),
                ],
                [InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="shop")],
            ]
            sent = await context.bot.send_message(
                chat_id=cid,
                text="Tabaccheria ‚Äî scegli una categoria:",
                reply_markup=InlineKeyboardMarkup(kb)
            )
            context.user_data["last_menu_msg_id"] = sent.message_id
            return

        # ---------- TABACCHERIA ITEMS (video per item) ---------- #
        if d in ("svc2_blunts", "svc2_papers", "svc2_filters", "svc2_kits"):
            item = self.tabaccheria_items.get(d)
            if not item:
                await q.answer("‚ùå Elemento non trovato!")
                return
        
            kb = [[InlineKeyboardButton("‚¨ÖÔ∏è Indietro", callback_data="service_2")]]
            sent = await context.bot.send_video(
                chat_id=cid,
                video=item["video_file_id"],
                caption=item["caption"],
                supports_streaming=True,
                reply_markup=InlineKeyboardMarkup(kb)
            )
            context.user_data["last_menu_msg_id"] = sent.message_id
            return

        # ---------- DETTAGLIO ALTRO (clean caption) ---------- #
        if d.startswith("service_"):
            sid = d.split("_", 1)[1]
            serv = self.services.get(sid)
            if not serv:
                await q.answer("‚ùå Elemento non trovato!")
                return
        
            parts = [f"üõ†Ô∏è *{serv['name']}*"]
            price = (serv.get("price") or "").strip()
            if price and price.lower() != "programma referral":
                parts.append(f"üíµ Prezzo:\n{price}")
            parts.append(f"üìù Descrizione: {serv['description']}")
            caption = "\n".join(parts)
        
            kb_back = InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Torna ad Altro", callback_data="back_to_services")]])
        
            if serv.get("video_file_id"):
                try:
                    sent = await context.bot.send_video(
                        chat_id=cid,
                        video=serv["video_file_id"],
                        caption=caption,
                        supports_streaming=True,
                        parse_mode=ParseMode.MARKDOWN,
                        reply_markup=kb_back
                    )
                    context.user_data["last_menu_msg_id"] = sent.message_id
                except BadRequest:
                    sent = await context.bot.send_message(
                        chat_id=cid, text=caption, parse_mode=ParseMode.MARKDOWN, reply_markup=kb_back
                    )
                    context.user_data["last_menu_msg_id"] = sent.message_id
            elif serv.get("photo_file_id"):
                try:
                    sent = await context.bot.send_photo(
                        chat_id=cid, photo=serv["photo_file_id"], caption=caption,
                        parse_mode=ParseMode.MARKDOWN, reply_markup=kb_back
                    )
                    context.user_data["last_menu_msg_id"] = sent.message_id
                except BadRequest:
                    sent = await context.bot.send_message(
                        chat_id=cid, text=caption, parse_mode=ParseMode.MARKDOWN, reply_markup=kb_back
                    )
                    context.user_data["last_menu_msg_id"] = sent.message_id
            else:
                sent = await context.bot.send_message(
                    chat_id=cid, text=caption, parse_mode=ParseMode.MARKDOWN, reply_markup=kb_back
                )
                context.user_data["last_menu_msg_id"] = sent.message_id
            return

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  MESSAGES  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        m   = update.effective_message
        usr = update.effective_user
        self.user_ids.add(usr.id)

        if usr and usr.id != ADMIN_USER_ID:
            txt = (
                m.text or m.caption or
                (f"<{type(m.effective_attachment).__name__}>" if m.effective_attachment else "<no text>")
            )
            await self._relay_to_admin(context, usr, txt)

        if usr and usr.id == ADMIN_USER_ID:
            if m.video:
                await m.reply_text(f"File ID del video:\n<code>{m.video.file_id}</code>", parse_mode=ParseMode.HTML); return
            if m.photo:
                await m.reply_text(f"File ID della foto:\n<code>{m.photo[-1].file_id}</code>", parse_mode=ParseMode.HTML); return

        t = m.text.lower() if m.text else ""
        if any(w in t for w in ("ciao", "salve")):
            await m.reply_text("Ciao! üëã Usa /start per iniziare.")
        elif "aiuto" in t or "help" in t:
            await m.reply_text("Usa /start per vedere il menu principale.")
        else:
            await m.reply_text("Non ho capito. Usa /start per vedere le opzioni disponibili.")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  MAIN  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #
def main():
    logger.info("Avvio del bot...")
    try:
        app = Application.builder().token(BOT_TOKEN).build()
        bot = ShopBot()

        app.add_handler(CommandHandler("start", bot.start))
        app.add_handler(CommandHandler("broadcast", bot.broadcast))
        app.add_handler(CallbackQueryHandler(bot.button_handler))
        app.add_handler(MessageHandler(filters.ALL, bot.handle_message))

        app.run_polling()
        logger.info("Bot terminato.")
    except Exception as e:
        logger.exception(f"‚ùå Errore critico: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()